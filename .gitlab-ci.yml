# This .gitlab-ci.yml defines a CI/CD pipeline for an infrastructure-as-code project using Ansible and Terraform.
# The pipeline includes three stages: lint-and-plan, provision, and configure. 
# It supports manual triggers from the GitLab UI and scheduled pipelines, as well as automatic 
# execution on the default branch.
# The pipeline uses a custom Docker image that includes Ansible, Terraform, and uv for managing Python dependencies.
# The lint-and-plan stage runs ansible-lint and Terraform plan, caching dependencies for efficiency. 
# The provision stage applies the Terraform plan, and the configure stage runs Ansible 
# playbooks to configure the provisioned infrastructure.
# The pipeline also defines an input variable for selecting the deployment environment (dev, staging, prod), 
# which is used to target specific Terraform configurations and Ansible inventories.

spec:
  inputs:
    environment: # Provide this on job run from the GitLab UI
      type: string
      options: ["dev", "prod"]
      default: "dev" 
      description: "Select the environment to deploy to"
---
# Use a custom Docker image that includes Ansible, Terraform, and uv for managing Python dependencies
# The image is built from the provided Dockerfile, which installs Ansible, Terraform, and necessary dependencies.
# The image tag includes versions for uv, Ansible, and Terraform to ensure consistency across CI runs.
# The final digit of the tag is the version of the Docker image itself, 
# which can be incremented for updates to the image without changing the underlying tool versions.

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "web"  # Enables manual UI trigger
    - if: $CI_PIPELINE_SOURCE == "schedule"  # Enables scheduled pipelines
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH  # Enables pipelines on main
    - if: $CI_COMMIT_TAG != null  # Enables pipelines on tags (e.g., for releases)
    
stages:
  - .pre
  - trigger_child_pipeline

generate-config:
  stage: .pre
  before_script:
    - git fetch --tags --prune-tags
  script:
    # Main branch: check if HEAD == latest tag
    - echo "Checking main branch $CI_COMMIT_SHA"
    - export LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

    - 'echo "image: huddlesk/uv-ansible-terraform-alpine:$LATEST_TAG"'
    - 'echo "image: huddlesk/uv-ansible-terraform-alpine:$LATEST_TAG" > generated-config.yml'
    - echo "Commit Tag $CI_COMMIT_TAG"

    # Skip check if not main branch
    - |
      if [ "$CI_COMMIT_BRANCH" != "main" ]; then
        echo "Not main branch ($CI_COMMIT_BRANCH). Skipping tag check."
        exit 0
      fi
    # Skip check if no tags found either
    - |
      if [ -z "$LATEST_TAG" ]; then
        echo "No tags found. Proceeding."
        exit 0
      fi
      
    - TAG_SHA=$(git rev-parse "$LATEST_TAG")
    - 'echo "Latest tag $LATEST_TAG points to: $TAG_SHA"'

    # Check if HEAD matches the latest tag and exit
    - |
      if [ "$TAG_SHA" = "$CI_COMMIT_SHA" ]; then
        echo "ERROR: HEAD ($CI_COMMIT_SHA) matches latest tag ($LATEST_TAG)."
        echo "Skipping redundant pipeline."
        exit 1  # Fails pipeline
      else
        echo "HEAD ahead of tags. Proceeding."
        exit 0
      fi
  allow_failure: false
  artifacts:
    paths:
      - generated-config.yml

trigger-child:
  stage: trigger_child_pipeline
  trigger:
    include:
      - local: .gitlab/ci/build_plan_provision_configure.yml  
        inputs:
          environment: $[[ inputs.environment ]]  
      - artifact: generated-config.yml
        job: generate-config 
    strategy: depend # Wait for child completion
  needs:
    - job: generate-config
      artifacts: true # Ensure artifact available
